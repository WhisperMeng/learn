# 概述

# 字段设计

  - 尽量使用整型便是字符串
    - 存储IP，使用INET_ATON(str)和INET_NTOA(number)来进行转化
    - MySQL内部的枚举类型（单选）和集合类型（多选）因为维护成本较高因此不常使用，通过关联表的方式来代替enum

  - 定长和非定长数据类型的选择
    - decimal不会损失精度，存储空间会随数据的增大而增大。double占用固定空间，较大数的存储会损失精度。非定长的还有varchar、text
    - 金额：对数据的精度要求较高，小数的运算和存储存在精度问题（不能将所有小数转换成二进制）
    - 定点数decimal：price decimal(8,2)有2位小数的定点数，定点数支持很大的数（甚至是超过int,bigint存储范围的数）
    - 小单位大数额避免出现小数
    - 字符串存储:定长char，非定长varchar、text（上限65535，其中varchar还会消耗1-3字节记录长度，而text使用额外空间记录长度）
  
  - 尽可能选择小的数据类型和指定短的长度

  - 尽可能使用not null
    - 非null字段的处理要比null字段的处理高效些！且不需要判断是否为null。
    - null在MySQL中，不好处理，存储需要额外空间，运算也需要特殊的运算符。如select null = null和select null <> null（<>为不等号）有着同样的结果，只能通过is null和is not null来判断字段是否为null。
    - MySQL中每条记录都需要额外的存储空间，表示每个字段是否为null。因此通常使用特殊的数据进行占位，比如int not null default 0、string not null default ‘’
  
  - 字段注释要完整，见名知意
  
  - 单表字段不宜过多
  > 二三十个就极限了
  
  - 可以预留字段
  > 在使用以上原则之前首先要满足业务需求
  
  - 关联表的设计
  > 外键foreign key只能实现一对一或一对多的映射
    - 一对多：
    > 使用外键
    - 多对多：
    > 单独创建一张表将多对多拆分成两个一对多
    - 一对一：
    > 通常使用相同的主键或者增加一个外键字段
  
  - 范式 Normal Format
    - 第一范式1NF：字段原子性
    > 字段不可再分割，关系型数据库，默认满足第一范式，注意比较容易出错的一点，在一对多的设计中使用逗号分隔多个外键，这种方法虽然存储方便，但不利于维护和索引
    - 第二范式：消除对主键的部分依赖
    > 在表中加上一个与业务逻辑无关的字段作为主键
    - 第三范式：消除对主键的传递依赖
    > 传递依赖即，B字段依赖于A，C字段又依赖于B。因此需要根据独立数据独立将此表拆分为两张表，通过外键关联，减少数据冗余。
  
  
# 存储引擎选择
  - 存储引擎选择
  > 早期问题：如何选择MyISAM和Innodb？现在不存在这个问题了，Innodb不断完善，从各个方面赶超MyISAM，也是MySQL默认使用的。
  - 功能差异
  
| 类型 | 支持 | 备注 |
| --- | --- | --- |
| InnoDB | 默认 | **支持事务, 行级锁, 外键** |
| MyISAM | 是 | **表级锁** |

  - 存储差异
  
|                                                              | MyISAM                                            | Innodb                                   |
| ------------------------------------------------------------ | ------------------------------------------------- | ---------------------------------------- |
| 文件格式                                                     | 数据和索引是分别存储的，数据`.MYD`，索引`.MYI`    | 数据和索引是集中存储的，`.ibd`           |
| 文件能否移动                                                 | 能，一张表就对应`.frm`、`MYD`、`MYI`3个文件       | 否，因为关联的还有`data`下的其它文件     |
| 记录存储顺序                                                 | 按记录插入顺序保存                                | 按主键大小有序插入                       |
| 空间碎片（删除记录并`flush table 表名`之后，表文件大小不变） | 产生。定时整理：使用命令`optimize table 表名`实现 | 不产生                                   |
| 事务                                                         | 不支持                                            | 支持                                     |
| 外键                                                         | 不支持                                            | 支持                                     |
| 锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的） | 表级锁定                                          | 行级锁定、表级锁定，锁定力度小并发能力高 |

    > 锁扩展 
    >
    > 表级锁（`table-level lock`）：`lock tables <table_name1>,<table_name2>... read/write`，`unlock tables <table_name1>,<table_name2>...`。其中`read`是共享锁，一旦锁定任何客户端都不可读；`write`是独占/写锁，只有加锁的客户端可读可写，其他客户端既不可读也不可写。锁定的是一张表或几张表。
    >
    > 行级锁（`row-level lock`）：锁定的是一行或几行记录。共享锁：`select * from <table_name> where <条件> LOCK IN SHARE MODE;`，对查询的记录增加共享锁；`select * from <table_name> where <条件> FOR UPDATE;`，对查询的记录增加排他锁。这里**值得注意**的是：`innodb`的行锁，其实是一个子范围锁，依据条件锁定部分范围，而不是就映射到具体的行上，因此还有一个学名：间隙锁。比如`select * from stu where id < 20 LOCK IN SHARE MODE`会锁定`id`在`20`左右以下的范围，你可能无法插入`id`为`18`或`22`的一条新纪录。
  
  - 选择依据
    - 如果没有特别的需求，使用默认的Innodb即可。
    > MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。
    > Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键保证数据完整性。比如OA自动化办公系统。

# 索引

  > 关键字与数据的映射关系称为索引（==包含关键字和对应的记录在磁盘中的地址==）。关键字是从数据当中提取的用于标识、检索数据的特定内容。
  
  - 索引检索为什么快
  
  > 关键字现对于数据本身数据量小
  > 关键字是有序的，可以二分法快速查找
  
  - MySQL中的索引类型
  
    - 普通索引（key）：对关键字没有限制
    - 唯一索引（unique key）：要求记录提供的关键字不能重复
    - 主键索引（primary key）：要求关键字唯一且不为null
    - 全文索引（fulltext key）
  
  - 索引语法管理
    - 查看索引
    - 创建索引
      - 创建表之后建立索引
      - 创建表时指定索引
    - 删除索引
    > 删除主键索引时，如果主键自增长，需要先取消自增长再删除索引
  
  - 执行计划Explain
  > 使用explain关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的，分析你的查询语句或是表结构的性能瓶颈。
  
  - 索引使用场景
  
    - where
    
    - order by
    > 没有索引时，查询出的数据会先外部排序（从硬盘读到内存使用内部排序，最后合并排序结果），这个操作影响性能。因为索引是有序的，逐条取出即可。
   
   - join
    > 对join语句匹配关系（on）涉及的字段建立索引能够提高效率
    
    - 索引覆盖
    > 如果要查询的字段都简历索引，那么搜索引擎会直接在索引表中查询而不会访问原始数据
  
  - 语法细节
  > 在满足索引使用的场景下（where/order by/join on或索引覆盖），索引也不一定被使用
  
    - 字段要独立出现
    - like查询，不能以通配符开头
    - 复合索引只对第一个字段有效
    - or，两边条件都有索引可用
    - 状态值，不容易使用到索引
  
  - 如何创建索引
    - 建立基础索引：在where、order by、join字段上建立索引
    - 优化，组合索引：基于业务逻辑
      - 如果条件经常性出现在一起，那么可以考虑将多字段索引升级为复合索引
      - 如果通过增加个别字段的索引，就可以出现索引覆盖，那么可以考虑为该字段建立索引
      - 查询时，不常用到的索引，应该删除掉
  
  - 前缀索引
  
  - 索引的存储结构

# 查询缓存
# 分区
# 水平分割和垂直分割
# 集群
# 典型SQL
# 慢查询日志
# 典型的服务器配置
# 压测工具
