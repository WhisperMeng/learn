# 概述

# 字段设计

  - 尽量使用整型便是字符串
    - 存储IP，使用INET_ATON(str)和INET_NTOA(number)来进行转化
    - MySQL内部的枚举类型（单选）和集合类型（多选）因为维护成本较高因此不常使用，通过关联表的方式来代替enum

  - 定长和非定长数据类型的选择
    - decimal不会损失精度，存储空间会随数据的增大而增大。double占用固定空间，较大数的存储会损失精度。非定长的还有varchar、text
    - 金额：对数据的精度要求较高，小数的运算和存储存在精度问题（不能将所有小数转换成二进制）
    - 定点数decimal：price decimal(8,2)有2位小数的定点数，定点数支持很大的数（甚至是超过int,bigint存储范围的数）
    - 小单位大数额避免出现小数
    - 字符串存储:定长char，非定长varchar、text（上限65535，其中varchar还会消耗1-3字节记录长度，而text使用额外空间记录长度）
  
  - 尽可能选择小的数据类型和指定短的长度

  - 尽可能使用not null
    - 非null字段的处理要比null字段的处理高效些！且不需要判断是否为null。
    - null在MySQL中，不好处理，存储需要额外空间，运算也需要特殊的运算符。如select null = null和select null <> null（<>为不等号）有着同样的结果，只能通过is null和is not null来判断字段是否为null。
    - MySQL中每条记录都需要额外的存储空间，表示每个字段是否为null。因此通常使用特殊的数据进行占位，比如int not null default 0、string not null default ‘’
  
  - 字段注释要完整，见名知意
  
  - 单表字段不宜过多
    - 二三十个就极限了
  
  - 可以预留字段
    - 在使用以上原则之前首先要满足业务需求
  
  - 关联表的设计
  > 外键foreign key只能实现一对一或一对多的映射
    - 一对多：
      - 使用外键
    - 多对多：
      - 单独创建一张表将多对多拆分成两个一对多
    - 一对一：
      - 通常使用相同的主键或者增加一个外键字段
  
  - 范式 Normal Format
    - 第一范式1NF：字段原子性
    > 字段不可再分割，关系型数据库，默认满足第一范式，注意比较容易出错的一点，在一对多的设计中使用逗号分隔多个外键，这种方法虽然存储方便，但不利于维护和索引
    - 第二范式：消除对主键的部分依赖
    > 在表中加上一个与业务逻辑无关的字段作为主键
    - 第三范式：消除对主键的传递依赖
    > 传递依赖即，B字段依赖于A，C字段又依赖于B。因此需要根据独立数据独立将此表拆分为两张表，通过外键关联，减少数据冗余。
  
  
# 存储引擎选择
  - 存储引擎选择
  > 早期问题：如何选择MyISAM和Innodb？现在不存在这个问题了，Innodb不断完善，从各个方面赶超MyISAM，也是MySQL默认使用的。
  - 功能差异
  
| 类型 | 支持 | 备注 |
| --- | --- | --- |
| InnoDB | 默认 | **支持事务, 行级锁, 外键** |
| MyISAM | 是 | **表级锁** |

  - 存储差异
  
|                                                              | MyISAM                                            | Innodb                                   |
| ------------------------------------------------------------ | ------------------------------------------------- | ---------------------------------------- |
| 文件格式                                                     | 数据和索引是分别存储的，数据`.MYD`，索引`.MYI`    | 数据和索引是集中存储的，`.ibd`           |
| 文件能否移动                                                 | 能，一张表就对应`.frm`、`MYD`、`MYI`3个文件       | 否，因为关联的还有`data`下的其它文件     |
| 记录存储顺序                                                 | 按记录插入顺序保存                                | 按主键大小有序插入                       |
| 空间碎片（删除记录并`flush table 表名`之后，表文件大小不变） | 产生。定时整理：使用命令`optimize table 表名`实现 | 不产生                                   |
| 事务                                                         | 不支持                                            | 支持                                     |
| 外键                                                         | 不支持                                            | 支持                                     |
| 锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的） | 表级锁定                                          | 行级锁定、表级锁定，锁定力度小并发能力高 |

    > 锁扩展 
    >
    > 表级锁（`table-level lock`）：`lock tables <table_name1>,<table_name2>... read/write`，`unlock tables <table_name1>,<table_name2>...`。其中`read`是共享锁，一旦锁定任何客户端都不可读；`write`是独占/写锁，只有加锁的客户端可读可写，其他客户端既不可读也不可写。锁定的是一张表或几张表。
    >
    > 行级锁（`row-level lock`）：锁定的是一行或几行记录。共享锁：`select * from <table_name> where <条件> LOCK IN SHARE MODE;`，对查询的记录增加共享锁；`select * from <table_name> where <条件> FOR UPDATE;`，对查询的记录增加排他锁。这里**值得注意**的是：`innodb`的行锁，其实是一个子范围锁，依据条件锁定部分范围，而不是就映射到具体的行上，因此还有一个学名：间隙锁。比如`select * from stu where id < 20 LOCK IN SHARE MODE`会锁定`id`在`20`左右以下的范围，你可能无法插入`id`为`18`或`22`的一条新纪录。
  
  - 选择依据
    - 如果没有特别的需求，使用默认的Innodb即可。
    > MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。
    > Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键保证数据完整性。比如OA自动化办公系统。

# 索引

  > 关键字与数据的映射关系称为索引（==包含关键字和对应的记录在磁盘中的地址==）。关键字是从数据当中提取的用于标识、检索数据的特定内容。
  
  - 索引检索为什么快
  - MySQL中的索引类型
  - 索引语法管理
  - 执行计划Explain
  - 索引使用场景
  - 语法细节
  - 如何创建索引
  - 前缀索引
  - 索引的存储结构

# 查询缓存
# 分区
# 水平分割和垂直分割
# 集群
# 典型SQL
# 慢查询日志
# 典型的服务器配置
# 压测工具
